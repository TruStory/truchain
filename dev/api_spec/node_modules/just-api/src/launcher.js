'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _child_process = require('child_process');

var childProcess = _interopRequireWildcard(_child_process);

var _suite = require('./suite');

var _suite2 = _interopRequireDefault(_suite);

var _utils = require('./utils');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Launcher extends _events2.default {

    constructor(specFiles, options) {
        super();

        this.specs = specFiles.slice(0);
        this.options = options;
        this.pendingFiles = specFiles.slice(0);
        this.runningFiles = [];
        this.suiteOptions = {};
        this.parallel = options.parallel;
        this.max_parallel = options.max_parallel;
        this.max_parallel_limit = options.max_parallel_limit;
        this.suiteOptions.grep = options.grep;
        this.reporterOptions = options.reporterOptions;
        this.results = [];

        this.setupReporters(options.reporters);
    }

    setupReporters(reporters) {
        if (!reporters) {
            console.error(`Reporters not set`);
            process.exit(1);
        }

        this.reporters = [];

        for (let Reporter of reporters) {
            try {
                let reporter = new Reporter(this, {
                    parallel: this.parallel,
                    reporterOptions: _extends({}, this.reporterOptions)
                });

                this.reporters.push(reporter);
            } catch (err) {
                console.error(`Error occurred while initializing reporter: ${Reporter.name} \n ${err.stack}`);
                process.exit(1);
            }
        }
    }

    async go() {
        const self = this;

        this.emit('start', this.pendingFiles.slice(0));

        if (self.parallel) {
            let parallelRuns;

            if (self.max_parallel >= self.pendingFiles.length) {
                parallelRuns = self.pendingFiles.length;
            } else {
                parallelRuns = self.max_parallel;
            }

            for (let run = 1; run <= parallelRuns; run++) {
                self.runNextSuite(self);
            }
        } else {
            for (let file of self.pendingFiles) {
                const suite = new _suite2.default(file, this.suiteOptions);
                this.emit('new suite', suite);
                await suite.launch();
                let result = suite.result;
                result.status = suite.status;
                self.results.push(result);
            }

            this.exit();
        }
    }

    runNextSuite(context) {
        let self = context;

        if (self.runningFiles.length === 0 && self.pendingFiles.length === 0) {
            self.exit();
        }

        let file = self.pendingFiles.shift();

        if (file) {
            let suite = new _suite2.default(file, self.suiteOptions);
            self.runningFiles.push(file);
            this.emit('new suite', suite);

            suite.on('end', function (suiteObject, error) {
                self.runningFiles.splice(self.runningFiles.indexOf(suiteObject.file), 1);
                let result = suiteObject.result;
                result.status = suiteObject.status;
                self.results.push(result);
                self.runNextSuite(self);
            });

            suite.launch();
        } else if (!file && self.runningFiles.length > 0) {
            console.log(`\n ${self.runningFiles.length} suite(s) are still running...`);
        }
    }

    exit() {
        this.emit('end');

        try {
            let failedSuites = this.results.filter(suiteResult => suiteResult.status !== 'pass' && suiteResult.status !== 'skip');
            console.log();
            process.exit(failedSuites.length);
        } catch (error) {
            console.log();
            process.exit(1);
        }
    }

}
exports.default = Launcher;
module.exports = exports['default'];